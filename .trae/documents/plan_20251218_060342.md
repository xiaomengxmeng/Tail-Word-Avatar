1. **问题分析**

   * 当前代码在发送消息时，只会检查消息内容是否包含**自己**的小尾巴，如果包含则不再添加

   * 但问题是，如果用户回复或引用了别人的消息，而别人的消息已经带有小尾巴，当前代码不会处理这种情况

   * 这会导致用户发送的消息中包含别人的小尾巴，即"复读别人的小尾巴"

2. **识别小尾巴格式**

   * 当前小尾巴的格式是：`\n\n\n>  小尾巴内容`

   * 其中，`\n\n\n` 是三个换行符，`>` 是一个大于号，后面跟两个空格，然后是小尾巴内容

   * 小尾巴通常出现在消息的末尾

3. **解决方案**

   * 在发送消息前，移除原始消息中所有符合小尾巴格式的内容

   * 然后再按照正常逻辑添加自己的小尾巴

   * 具体修改步骤：

     1. 在 `content` 函数中，添加移除别人小尾巴的逻辑
     2. 使用正则表达式匹配并移除小尾巴格式的内容
     3. 然后再检查是否包含自己的小尾巴，按照原逻辑处理

4. **修改后的代码结构**

   ```javascript
   content: function () {
       // 获取原始消息内容
       let originalContent = t;
       
       // 移除原始消息中所有符合小尾巴格式的内容
       // 小尾巴格式：\n\n\n>  小尾巴内容
       originalContent = originalContent.replace(/\n\n\n>  .*/g, '');
       
       // 获取当前小尾巴文本
       let currentSuffix = getCurrentSuffixText();

       // 处理小尾巴和单词
       if (t.trim().length == 0 || (!suffixFlag) || needwb == 0 || t.trim().startsWith('凌 ') || t.trim().startsWith('鸽 ') || t.trim().startsWith('小冰 ') || t.trim().startsWith('冰冰 ') || t.trim().startsWith('点歌 ') || t.trim().startsWith('TTS ') || t.trim().startsWith('朗读 ') || originalContent.includes(currentSuffix)) {
           return originalContent;
       } else if (wordCount === 0) {
           return originalContent + '\n\n\n>  ' + currentSuffix;
       } else {
           // 定义包含小尾巴的wbMsg
           var wbMsg = '\n\n\n>  ' + currentSuffix;
           return originalContent + wordMsg + wbMsg;
       }
   }(),
   ```

5. **预期效果**

   * 当用户发送的消息内容包含别人的小尾巴时，系统会先移除别人的小尾巴

   * 然后再按照正常逻辑添加自己的小尾巴

   * 这将避免用户复读别人的小尾巴，提高消息的整洁度和用户体验

6. **代码验证**

   * 所有修改均需通过语法检查，确保代码可以正常运行

   * 修复后的代码应遵循原有的代码风格和逻辑

   * 修复后的代码不应影响其他功能的正常运行

